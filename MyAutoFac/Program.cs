using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Autofac;

namespace MyAutoFac
{
    class Program
    {
        static IContainer Container { get; set; }

        static void Main(string[] args)
        {
            try
            {
                Console.WriteLine("-------start---------");

                Register();

                Resolve();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

            Console.WriteLine("-------end---------");
            Console.ReadKey();
        }

        static void Register()
        {
            Console.WriteLine("--- start register ---");

            var builder = new ContainerBuilder();

            //1.by reflection
            ReflectionComponents(builder);

            //2.by instance
            InstanceComponents(builder);

            //3.by lambda expression
            LambdaExpressionComponents(builder);

            PassingParametersToRegister(builder);

            PropertyAndMethodInjection(builder);

            Container = builder.Build();

            Console.WriteLine("--- finish register ---");
        }

        /// <summary>
        /// Components can be created via reflection (by registering a specific .NET type or open generic); 
        /// </summary>
        /// <param name="builder"></param>
        static void ReflectionComponents(ContainerBuilder builder)
        {
            //Register by Type
            //Components generated by reflection are typically registered by type
            //Any component type you register via RegisterType must be a concrete type.
            builder.RegisterType<CA>();
            builder.RegisterType(typeof(CB));

            //Autofac automatically uses the constructor for your class 
            //with the most parameters that are able to be obtained from the container.

            //You can manually choose a particular constructor to use and override the automatic choice 
            //by registering your component with the UsingConstructor method and a list of types representing the parameter types in the constructor:
            builder.RegisterType<CA>().UsingConstructor(typeof(CB));
            //builder.RegisterType<CA>().UsingConstructor();
        }

        /// <summary>
        /// by providing a ready-made instance (an instance of an object you created);
        /// </summary>
        /// <param name="builder"></param>
        static void InstanceComponents(ContainerBuilder builder)
        {
            //The default service exposed by an instance is the concrete type of the instance.
            var cb = new CB("xxx");
            builder.RegisterInstance(cb).As<IB>();

            //相同的service,以最后注册的为准
            var cb2 = new CB("yyy");
            builder.RegisterInstance(cb2).As<IB>();
        }

        /// <summary>
        ///  via lambda expression (an anonymous function that executes to instantiate your object). 
        /// </summary>
        /// <param name="builder"></param>
        static void LambdaExpressionComponents(ContainerBuilder builder)
        {
            //Things get messy, though, when component creation logic goes beyond a simple constructor call.
            //Autofac can accept a delegate or lambda expression to be used as a component creator:
            //The parameter c provided to the expression is the component context (an IComponentContext object) 
            //      in which the component is being created. You can use this to resolve other values from the container to assist in creating your component.
            //The default service provided by an expression-created component is the inferred return type of the expression.

            builder.Register(c => new CA(c.Resolve<CB>()));

            //Property Injection
            //Property injection is not recommended in the majority of cases.
            //Alternatives like the Null Object pattern, overloaded constructors or constructor parameter default values 
            //make it possible to create cleaner, “immutable” components with optional dependencies using constructor injection.
            builder.Register(c => new CA() { cbtemp = c.Resolve<CB>() });

            //Selection of an Implementation by Parameter Value
            builder.Register<CALambda>((c, a) =>
            {
                var id = a.Named<int>("id");

                if (id == 0)
                    return new CALambda("no id");
                else
                    return new CALambda("by id " + id);
            });
        }

        /// <summary>
        /// When you register components you have the ability to provide a set of parameters 
        /// that can be used during the resolution of services based on that component.
        /// </summary>
        /// <param name="builder"></param>
        static void PassingParametersToRegister(ContainerBuilder builder)
        {
            //Parameters with Reflection Components
            //When you register a reflection-based component, the constructor of the type may require a parameter 
            //that can’t be resolved from the container. You can use a parameter on the registration to provide that value.

            //1.You could use a lambda expression component for that:
            //passing the parameter value at registration time
            builder.Register(c => { return new CBLambdaAtRegistration("PassingParametersToRegister lambda at registration time"); });
            //passing the parameter value at service resolution time
            builder.Register((c, p) => new CBLambdaAtResolution(p.Named<string>("msg")));

            //2.Or you could pass a parameter to a reflection component registration:
            // Using a NAMED parameter:
            builder.RegisterType<CBReflectionNamed>().WithParameter("msg", "PassingParametersToRegister Using a NAMED parameter");
            // Using a TYPED parameter:
            builder.RegisterType<CBReflectionTyped>().WithParameter(new TypedParameter(typeof(string), "PassingParametersToRegister Using a TYPED parameter"));
            // Using a RESOLVED parameter:
            builder.RegisterType<CBReflectionResolved>().WithParameter(
                new Autofac.Core.ResolvedParameter(
                    (pi, ctx) => pi.ParameterType == typeof(string) && pi.Name == "msg",
                    (pi, ctx) => "PassingParametersToRegister Using a RESOLVED parameter"));
        }

        /// <summary>
        /// Property injection uses writeable properties rather than constructor parameters to perform injection. 
        /// Method injection sets dependencies by calling a method.
        /// </summary>
        /// <param name="builder"></param>
        static void PropertyAndMethodInjection(ContainerBuilder builder)
        {
            //Property Injection
            //1.If the component is a lambda expression component, use an object initializer:
            builder.Register(c => new CB() { cbString = "Property Injection" });

            //2.If the component is a reflection component, use the PropertiesAutowired() modifier to inject properties:
            builder.RegisterType<CBPropertyInjection1>();
            builder.RegisterType<CBPropertyInjection2>().PropertiesAutowired();


            //Method Injection
            //The simplest way to call a method to set a value on a component 
            //is to use a lambda expression component and handle the method call right in the activator:
            builder.Register(c =>
            {
                var c3 = new CBPropertyInjection3();
                var c1 = c.Resolve<CBPropertyInjection1>();
                c3.SetCBPropertyInjection1(c1);
                return c3;
            });
        }

        static void Resolve()
        {
            Console.WriteLine("--- start resolve ---");

            using (var scope = Container.BeginLifetimeScope())
            {
                //同1个单例,来自RegisterInstance
                //不会再调用构造函数
                var ib1 = scope.Resolve<IB>();
                var ib2 = scope.Resolve<IB>();
                Console.WriteLine("ib1.msg " + ib1);
                Console.WriteLine("ib1==ib2 {0}", ib1 == ib2);

                //不同的实例
                //调用构造函数生成
                var cb1 = scope.Resolve<CB>();
                var cb2 = scope.Resolve<CB>();
                Console.WriteLine("cb1==cb2 {0}", cb1 == cb2);

                var ca1 = scope.Resolve<CA>();

                //传入参数解析
                var caa = scope.Resolve<CALambda>(new NamedParameter("id", 10));

                var cbPi2 = scope.Resolve<CBPropertyInjection2>();
                var cbpi3 = scope.Resolve<CBPropertyInjection3>();

                //解析可能未注册的组件
                //scope.ResolveOptional<CBResolveOptional>();
                CBResolveOptional cbResolveOptional = ResolutionExtensions.ResolveOptional<CBResolveOptional>(scope);
                CBResolveOptional cbResolveOptional2 = null;
                if (!scope.TryResolve<CBResolveOptional>(out cbResolveOptional2))
                {
                    Console.WriteLine("try resolve CBResolveOptional");
                }

                var tmpCBReflectionNamed = scope.Resolve<CBReflectionNamed>();
                var tmpCBReflectionTyped = scope.Resolve<CBReflectionTyped>();
            }

            PassingParametersToResolve();

            Console.WriteLine("--- finish resolve ---");
        }

        static void PassingParametersToResolve()
        {
            using (var scope = Container.BeginLifetimeScope())
            {
                //Parameters with Reflection Components
                var cbReflectionNamed = scope.Resolve<CBReflectionNamed>(new NamedParameter("msg", "namedparameter at resolution time"));
                var xx = scope.Resolve<CBReflectionTyped>(new TypedParameter(typeof(string), "typedparameter at resolution time"));
                var cbReflectionResolved = scope.Resolve<CBReflectionResolved>(
                    new Autofac.Core.ResolvedParameter(
                    (pi, ctx) => pi.Name == "msg",
                    (pi, ctx) => "resolvedparameter at resolution time"));

                //Parameters with Lambda Expression Components
                var cbLambdaResolved = scope.Resolve<CBLambdaAtResolution>(
                    new NamedParameter("msg", "PassingParameters lambda at service resolution time"));
            }
        }
    }
}

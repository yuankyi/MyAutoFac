# 使用Autofac的基本步骤

1. Add Autofac references.
2. At application startup…
3. Create a ContainerBuilder.
4. Register components.
5. Build the container and store it for later use.
6. During application execution…
7. Create a lifetime scope from the container.
8. Use the lifetime scope to resolve instances of the components.

## 1. Add Autofac references.

The easiest way to do this is through NuGet. The “Autofac” package has all the core functionality you’ll need.

## 2. At application startup...

At application startup, you need to create a ContainerBuilder and register your components with it. 

A *component* is an expression, .NET type, or other bit of code that exposes one or more *services* and can take in other *dependencies*.

## 3. Create a ContainerBuilder.

```c#
// Create your builder.
var builder = new ContainerBuilder();
```

## 4. Register components.

You could address that type in one of two ways:

- As the type itself, `SomeType`
- As the interface, an `IService`

In this case, the *component* is `SomeType` and the *services* it exposes are `SomeType` and `IService`

```c#
// Usually you're only interested in exposing the type
// via its interface:
builder.RegisterType<SomeType>().As<IService>();

// However, if you want BOTH services (not as common)
// you can say so:
builder.RegisterType<SomeType>().AsSelf().As<IService>();
```

### Registration Concepts

**Components** can be created 

- via **reflection** (by registering a specific .NET type or open generic); **(使用简单方便)**
- by providing a ready-made **instance** (an instance of an object you created); **(指定实例,适用于特殊场景)**
- via lambda **expression** (an anonymous function that executes to instantiate your object).**(适用于较复杂的场景)**

```c#
// Register types that expose interfaces...
builder.RegisterType<ConsoleLogger>().As<ILogger>();

// Register instances of objects you create...
var output = new StringWriter();
builder.RegisterInstance(output).As<TextWriter>();

// Register expressions that execute to create objects...
builder.Register(c => new ConfigReader("mysection")).As<IConfigReader>();
```

#### Reflection Components

Components generated by reflection are typically registered by type:

Any component type you register via `RegisterType` must be a concrete type.

```c#
var builder = new ContainerBuilder();
builder.RegisterType<ConsoleLogger>();
builder.RegisterType(typeof(ConfigReader));
```

Autofac automatically uses the constructor for your class with  the most parameters that are able to be obtained from the container.

You can manually choose a particular constructor 

```c#
builder.RegisterType<MyComponent>()
       .UsingConstructor(typeof(ILogger), typeof(IConfigReader));
```

#### Instance Components

In some cases, you may want to pre-generate an instance of an object and add it to the container for use by registered components. You can do  this using the `RegisterInstance` method:

```c#
var output = new StringWriter();
builder.RegisterInstance(output).As<TextWriter>();
```

The default service exposed by an instance is the concrete type of the instance.

#### Lambda Expression Components

Reflection is a pretty good default choice for component creation.  Things get messy, though, when component creation logic goes beyond a  simple constructor call.

Autofac can accept a delegate or lambda expression to be used as a component creator:

```c#
builder.Register(c => new A(c.Resolve<B>()));
```

The parameter `c` provided to the expression is the *component context* (an `IComponentContext` object) in which the component is being created. 

The default service provided by an expression-created component is the inferred return type of the expression.

**Complex Parameters**

Constructor parameters can’t always be declared with simple constant  values. Rather than puzzling over how to construct a value of a certain  type using an XML configuration syntax, use code:

```c#
builder.Register(c => new UserSession(DateTime.Now.AddMinutes(25)));
```

**Property Injection**

While Autofac offers a more first-class approach to property injection, you can use expressions and property initializers to populate properties as well:

```c#
builder.Register(c => new A(){ MyB = c.ResolveOptional<B>() });
```

Property injection is not recommended in the majority of cases.

**Selection of an Implementation by Parameter Value**

One of the great benefits of isolating component creation is that the concrete type can be varied. This is often done at runtime, not just  configuration time:

```c#
builder.Register<CreditCard>(
  (c, p) =>
    {
      var accountId = p.Named<string>("accountId");
      if (accountId.StartsWith("9"))
      {
        return new GoldCard(accountId);
      }
      else
      {
        return new StandardCard(accountId);
      }
    });
```

Using this registration would look like:

```c#
var card = container.Resolve<CreditCard>(new NamedParameter("accountId", "12345"));
```

**Default Registrations**

If more than one component exposes the same service, Autofac will use the last registered component as the default provider of that service:

```
builder.RegisterType<ConsoleLogger>().As<ILogger>();
builder.RegisterType<FileLogger>().As<ILogger>();
```

To override this behavior, use the `PreserveExistingDefaults()` modifier:

```c#
builder.RegisterType<ConsoleLogger>().As<ILogger>();
builder.RegisterType<FileLogger>().As<ILogger>().PreserveExistingDefaults();
```

### Passing Parameters to Register

**Available Parameter Types**

Autofac offers several different parameter matching strategies:

- `NamedParameter` - match target parameters by name
- `TypedParameter` - match target parameters by type (exact type match required)
- `ResolvedParameter` - flexible parameter matching

`NamedParameter` and `TypedParameter` can supply constant values only.

`ResolvedParameter` can be used as a way to supply values dynamically retrieved from the container, e.g. by resolving a service by name.

#### Parameters with Reflection Components

When you register a reflection-based component, **the constructor of the  type may require a parameter that can’t be resolved from the container**.  You can use a parameter on the registration to provide that value.**(注册时确定实例)**

Say you have a configuration reader that needs a configuration section name passed in:

```c#
public class ConfigReader : IConfigReader
{
  public ConfigReader(string configSectionName)
  {
    // Store config section name
  }

  // ...read configuration based on the section name.
}
```

You could use a lambda expression component for that:

```c#
builder.Register(c => new ConfigReader("sectionName")).As<IConfigReader>();
```

Or you could pass a parameter to a reflection component registration:

```c#
// Using a NAMED parameter:
builder.RegisterType<ConfigReader>()
       .As<IConfigReader>()
       .WithParameter("configSectionName", "sectionName");

// Using a TYPED parameter:
builder.RegisterType<ConfigReader>()
       .As<IConfigReader>()
       .WithParameter(new TypedParameter(typeof(string), "sectionName"));

// Using a RESOLVED parameter:
builder.RegisterType<ConfigReader>()
       .As<IConfigReader>()
       .WithParameter(
         new ResolvedParameter(
           (pi, ctx) => pi.ParameterType == typeof(string) && pi.Name == "configSectionName",
           (pi, ctx) => "sectionName"));
```

#### Parameters with Lambda Expression Components

With lambda expression component registrations, rather than passing the parameter value at registration time you enable the ability to **pass the value at service resolution time**. **(解析时确定实例)**

```
// Use TWO parameters to the registration delegate:
// c = The current IComponentContext to dynamically resolve dependencies
// p = An IEnumerable<Parameter> with the incoming parameter set
builder.Register((c, p) =>
                 new ConfigReader(p.Named<string>("configSectionName")))
       .As<IConfigReader>();
```

When resolving with parameters, your lambda will use the parameters passed in:

```
var reader = scope.Resolve<IConfigReader>(new NamedParameter("configSectionName", "sectionName"));
```

## 5. Build the container and store it for later use.

```c#
using System;
using Autofac;

namespace DemoApp
{
  public class Program
  {
    private static IContainer Container { get; set; }

    static void Main(string[] args)
    {
      var builder = new ContainerBuilder();
      builder.RegisterType<ConsoleOutput>().As<IOutput>();
      builder.RegisterType<TodayWriter>().As<IDateWriter>();
      Container = builder.Build();

      // The WriteDate method is where we'll make use
      // of our dependency injection. We'll define that
      // in a bit.
      WriteDate();
    }
  }
}
```

We also need to store the container so it can be used to resolve types later.

Now we have a *container* with all of the *components* registered and they’re exposing the proper *services*. Let’s make use of it.

## 6. During application execution…

During application execution, you’ll need to make use of the components you registered. You do this by *resolving* them from a *lifetime scope*.

It is not recommended to resolve from the container directly, however.**(may result in a memory leak)**

## 7. Create a lifetime scope from the container.

You can create a lifetime scope by calling the `BeginLifetimeScope()` method on any existing lifetime scope, starting with the root container. Lifetime scopes are disposable and they track component disposal, **so make sure  you always call “Dispose()”” or wrap them in “using” statements.**

```c#
      using (var scope = Container.BeginLifetimeScope())
      {
        var writer = scope.Resolve<IDateWriter>();
        writer.WriteDate();
      }
```

## 8. Use the lifetime scope to resolve instances of the components.

### Passing Parameters to Resolve

When it’s time to resolve services, you may find that you need to pass parameters to the resolution. (If you know the values at registration time, you can provide them in the registration instead.)

**Available Parameter Types**

Autofac offers several different parameter matching strategies:

- `NamedParameter` - match target parameters by name
- `TypedParameter` - match target parameters by type (exact type match required)
- `ResolvedParameter` - flexible parameter matching

`NamedParameter` and `TypedParameter` can supply constant values only.

`ResolvedParameter` can be used as a way to supply values dynamically retrieved from the container, e.g. by resolving a service by name.

#### Parameters with Reflection Components

When you resolve a reflection-based component, the constructor of the  type may require a parameter that you need to specify based on a runtime value, **something that isn’t available at registration time**. You can use a parameter in the `Resolve()` method call to provide that value.

```c#
var reader = scope.Resolve<ConfigReader>(new NamedParameter("configSectionName", "sectionName"));
```

As with registration-time parameters, the NamedParameter in the example will **map to the corresponding named constructor parameter**, assuming the ConfigReader component was registered using reflection.

If you have more than one parameter, just pass them all in via the `Resolve()` method:

```c#
var service = scope.Resolve<AnotherService>(
                new NamedParameter("id", "service-identifier"),
                new TypedParameter(typeof(Guid), Guid.NewGuid()),
                new ResolvedParameter(
                  (pi, ctx) => pi.ParameterType == typeof(ILog) && pi.Name == "logger",
                  (pi, ctx) => LogManager.GetLogger("service")));
```

#### Parameters with Lambda Expression Components

With lambda expression component registrations, you need to add the  parameter handling inside your lambda expression so when the `Resolve()` call passes them in, you can take advantage of them.

```c#
// Use TWO parameters to the registration delegate:
// c = The current IComponentContext to dynamically resolve dependencies
// p = An IEnumerable<Parameter> with the incoming parameter set
builder.Register((c, p) =>
                 new ConfigReader(p.Named<string>("configSectionName")))
       .As<IConfigReader>();
```

Now when you resolve the `IConfigReader`, your lambda will use the parameters passed in:

```c#
var reader = scope.Resolve<IConfigReader>(new NamedParameter("configSectionName", "sectionName"));
```
